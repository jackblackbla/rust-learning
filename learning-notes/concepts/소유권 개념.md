# 러스트의 소유권 (Ownership)

## 소유권이란?

- 러스트의 핵심 기능
- 메모리를 관리하는 방법
- 컴파일 타임에 컴파일러가 체크하는 규칙들로 구성
- 런타임 비용 없음

## 메모리 관리 방식 비교

1. 가비지 컬렉션(GC)
   - 프로그램 실행 중 사용하지 않는 메모리를 찾아 정리
   - 예: Java, Python

2. 수동 메모리 관리
   - 프로그래머가 직접 할당/해제
   - 예: C/C++

3. 러스트의 방식
   - 컴파일 타임에 소유권 시스템으로 관리
   - 자동으로 메모리 해제 (스코프 기반)

## 메모리 구조
### 스택 (Stack)
- 고정된 크기의 데이터 저장
- LIFO (Last In First Out)
- 빠른 데이터 접근
- 컴파일 타임에 크기가 알려진 데이터

### 힙 (Heap)
- 가변 크기 데이터 저장
- 런타임에 크기가 결정되는 데이터
- 상대적으로 느린 데이터 접근
- 메모리 할당이 필요함

## 소유권 규칙

1. 러스트의 각 값은 하나의 소유자를 가짐
2. 한 번에 하나의 소유자만 존재
3. 소유자가 스코프를 벗어나면 값은 제거됨

## 소유권 이동 (Move)

```rust
let s1 = String::from("hello");
let s2 = s1; // s1의 소유권이 s2로 이동
// 이 시점에서 s1은 더 이상 유효하지 않음
```

### 이동이 발생하는 경우

1. 변수 대입
2. 함수 인자로 전달
3. 함수에서 반환

## Clone (깊은 복사)

```rust
let s1 = String::from("hello");
let s2 = s1.clone(); // 데이터의 깊은 복사 발생
// s1, s2 모두 유효
```

## Copy 트레잇

- 스택에만 저장되는 데이터 타입의 특성
- 이동 대신 값이 복사됨
- Copy가 가능한 타입들:
  - 정수형 (i32, u32 등)
  - 불리언 (bool)
  - 부동소수점 (f64 등)
  - 문자 (char)
  - Copy 가능한 타입으로만 구성된 튜플

## 함수와 소유권
```rust
fn main() {
    let s = String::from("hello");
    takes_ownership(s); // s의 소유권이 함수로 이동
    // s는 이제 유효하지 않음
    
    let x = 5;
    makes_copy(x); // Copy 트레잇이 있으므로 x는 계속 유효
}
```

## 소유권 반환
```rust
fn give_ownership() -> String {
    let s = String::from("hello");
    s // 호출한 함수로 소유권 이동
}
```